var documenterSearchIndex = {"docs":
[{"location":"1.2.10_algorithm_analysis/#.2.10-Algorithm-analysis","page":"1.2.10 Alg Analysis","title":"1.2.10 Algorithm analysis","text":"","category":"section"},{"location":"1.2.10_algorithm_analysis/","page":"1.2.10 Alg Analysis","title":"1.2.10 Alg Analysis","text":"Note the use of Chebychevs inequality (p 98):","category":"page"},{"location":"1.2.10_algorithm_analysis/","page":"1.2.10 Alg Analysis","title":"1.2.10 Alg Analysis","text":"Given a distribution A with mean µ and standard deviation σ, Then the probability of being r times the the standard deviation away from the mean is less than 1/r²:","category":"page"},{"location":"1.2.10_algorithm_analysis/","page":"1.2.10 Alg Analysis","title":"1.2.10 Alg Analysis","text":"$","category":"page"},{"location":"1.2.10_algorithm_analysis/","page":"1.2.10 Alg Analysis","title":"1.2.10 Alg Analysis","text":"P(|A - µ| > rσ) < 1/r² $","category":"page"},{"location":"1.2.1_bezout/#Section-1.2.1:-Bezout's-identity","page":"1.2.1: Bezout's identity","title":"Section 1.2.1: Bezout's identity","text":"","category":"section"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"In Section 1.2.1, Knuth introduces induction.","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"He also states, proves and implements Bezout's identity which he calls the \"Extended Euclud's algorithm\":","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"Given two positive integers, m, n, we compute the common greates divisor, d, and also integers a, b (not needed to be positive) such that d = am + bn.","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"As wikipedia notes, this is the prototype of a primary ideal.","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"Knuth also calls this algorithm E, but I'll call it B:","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"Input: n, m","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"[ Initialize ] a' = b = 1, a = b' = 0, c = m, d = n\n[ Divide ] q = c ÷ d; r = c % d (c = qd + r ie m = qn + r)\n[ Remainder zero? ] r == 0 && return (d=n, a=1, b=q)\n[ Recycle ] c = d, d = r, t = a', a' = a, a = t-qa, t = b' , b' = b, b = t - qb, goto 2.","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"This can be done a bit simpler, but we do need to remember a and b over 2 iterations:","category":"page"},{"location":"1.2.1_bezout/","page":"1.2.1: Bezout's identity","title":"1.2.1: Bezout's identity","text":"[ Initialize ] a = b2 = 0, b = a2 = 1\n[ Divide ] q = m ÷ n; r = m % n (m = qn + r)\n Recycle  = (n, r, a2 - qa, b2 - qb, a, b)\n[ Remainder zero? ] r == 0 && return (a, b, m)\ngoto 2","category":"page"},{"location":"7.0_graphs/#Chapter-7.-Graphs","page":"7.0: Graphs","title":"Chapter 7. Graphs","text":"","category":"section"},{"location":"7.0_graphs/#Adjacency-matrix","page":"7.0: Graphs","title":"Adjacency matrix","text":"","category":"section"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"The adjacency matrix of a directed graph is defined on page 19 and used on page 20.","category":"page"},{"location":"7.0_graphs/#SGB-data-structure","page":"7.0: Graphs","title":"SGB data structure","text":"","category":"section"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"The SGB (Stanford GraphBase) datastructure for directed graphs is defined on page 21.","category":"page"},{"location":"7.0_graphs/#Data-structures-and-methods","page":"7.0: Graphs","title":"Data structures and methods","text":"","category":"section"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"I'll like to be able to convert between representations like adjaceny matrix, SGB form and other representations.","category":"page"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"struct AdjacencyMatrix\n    A::Matrix{Int}\nend","category":"page"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"struct SgbArc\n    TIP::Int\n    NEXT::Union{Missing,SbgArc}\nend\nstruct SgbVertex\n    NAME::String\n    ARCS::SgbArc\nend\nstruct SgbDigraph\n    nodes::Vector{SgbVertex}\nend","category":"page"},{"location":"7.0_graphs/#TODO","page":"7.0: Graphs","title":"TODO","text":"","category":"section"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"adjacency(x::SgbDigraph)\nsdbDigraph(x::AdjacencyMatrix)\nAlgorith B (bipartate testing) p22 ff","category":"page"},{"location":"7.0_graphs/","page":"7.0: Graphs","title":"7.0: Graphs","text":"Before the graphs there are some interesting claims about latin squares that could be nice to check.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TheArtOfComputerProgramming","category":"page"},{"location":"#The-Art-Of-Computer-Programming","page":"Home","title":"The Art Of Computer Programming","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"These are my notes from reading Knuth: The art of Computer programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TheArtOfComputerProgramming]","category":"page"},{"location":"1.1_euclid/#Chapter-1.1:-Euclids-algorithm","page":"1.1: Euclid alg","title":"Chapter 1.1: Euclids algorithm","text":"","category":"section"},{"location":"1.1_euclid/#Algorithm-E:-Euclids-algorithm-for-finding-gcd(m,n)","page":"1.1: Euclid alg","title":"Algorithm E: Euclids algorithm for finding gcd(m,n)","text":"","category":"section"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"Input: m, n positive integers.","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"E1 [ find remainder ] r = m % n\nE2 [ is remainder zero ] r == 0 && return(n)\nE3  Reduce  = (n,r) . Goto E1","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"Let's implement in Julia:","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"function E(m,n)\n    while (r = m % n) != 0\n        (m,n) = (n,r)\n    end\n    n\nend\n","category":"page"},{"location":"1.1_euclid/#Analysis","page":"1.1: Euclid alg","title":"Analysis","text":"","category":"section"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"Knuth's goes a bit into the analysis be looking at the average number of iterations neded for a given n.","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"T_n","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":": = average over all integers m > 0 of time sstep E1 of the algorithm E is performed. [p 7]","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"He argues that we only need to check m = n, so we get the following implementation:","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"function T(n0)\n    i=0\n    for m in 1:n0\n        n = n0\n        while (r = m % n) != 0\n            (m,n) = (n,r)\n            i = i + 1\n        end\n        @debug m, n, i\n    end\n    i/n0\nend","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"He claims that asymptotically, this is 12log(2)pi^2 log(n). we can check this by plotting.","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"using Plots\nf(n) = 12log(2)/pi^2*log(n)\nn = 1000; plot([T.(1:n) f.(1:n)], label=[\"T(n)\" \"12log(2)/pi^2log(n)\"], title=\"Average number of iterations of gcd\")","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"(Image: gcd iterations)","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"We can also estimate it by fitting a log curve to the simulation and plot the difference between the estimated coefficient and the stated one:","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"using LsqFit, Plots\n\nmodel(x,p) = p[1]*log.(x)\np0 = [1.]\nn = 500; f1 = curve_fit(model, 1.:n, T.(1.:n), p0)\ncoef(f1)[1]*pi^2/log(2)-12\n\nfunction residual(n)\n    model(x,p) = p[1]*log.(x)\n    p0 = [1.]\n    f1 = curve_fit(model, 1.:n, T.(1.:n), p0)\n    coef(f1)[1] - 12log(2)/pi^2\nend\n\nplot(100:100:1000,residual.(100:100:1000), ylims=[residual(100)*1.1,0], label=\"residual\", title=\"Coefficient -  12log(2)/pi^2\")\n","category":"page"},{"location":"1.1_euclid/","page":"1.1: Euclid alg","title":"1.1: Euclid alg","text":"(Image: model convergence)","category":"page"}]
}
